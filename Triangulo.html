<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graficacion</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body onload="limpiar();">
    <section class="flex text-[#EEEEEE]">
        <div class="min-w-[250px] max-w-[30%] px-5 h-screen bg-[#31363F]">            
            <h2 class="mt-5 mb-6 text-center text-4xl font-medium">Triangulos</h2>
            <h1>Primera cordenada</h1>
            <div class="flex mb-3 gap-5 justify-center">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="x1" type="number" name="" id="inputX1" oninput="updateX1();">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="y1" type="number" name="" id="inputY1" oninput="updateY1();">
            </div>
            <h1>Segunda cordenada</h1>
            <div class="flex mb-3 gap-5 justify-center">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="x2" type="number" name="" id="inputX2" oninput="updateX2();">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="y2" type="number" name="" id="inputY2" oninput="updateY2();" >
            </div>
            <h1>Tercera cordenada</h1>
            <div class="flex gap-5 justify-center">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="x3" type="number" name="" id="inputX3" oninput="updateX3();">
                <input class="w-20 h-10 px-2 bg-[#76ABAE] text-[#222831] rounded-lg placeholder:text-[#EEEEEE]" placeholder="y3" type="number" name="" id="inputY3" oninput="updateY3();" >
            </div>
            <div class="flex gap-5">
                <button type="button" id="boton" class="w-full py-1 my-5 bg-[#EEEEEE] text-[#222831] rounded-md font-medium hover:bg-[#76ABAE] hover:text-[#EEEEEE]" onclick="start()">
                    Dibuja
                </button>
                <button type="button" id="boton" class="w-full py-1 my-5 bg-[#EEEEEE] text-[#222831] rounded-md font-medium hover:bg-[#76ABAE] hover:text-[#EEEEEE]" onclick="limpiar()">
                    Limpiar
                </button>
            </div>
            <div class="flex">
                <boton type="button" id="Mostrar" class="text-center py-3 w-full bg-[#76ABAE]">
                    Mostrar tablas
                </boton>
            </div>

            <img class="mt-5 h-auto rounded-md bottom-0" src="neco-arc.gif" alt="neko-girl">

        </div>
        <div class="h-full">
            <canvas width="1225" height="700" id="webgl-canvas"></canvas>
        </div>
    </section>
    <dialog id="dialog" class="top-40 py-5 min-w-[400px] px-5 rounded-lg bg-[#31363F] border-4 border-[#222831]"
    >
        <button id="cerrarDialogo" class="absolute right-10 py-1 px-3 font-bold text-[#31363F] bg-[#76ABAE] rounded-full">
            X
        </button>
        <h3 class="pb-6 text-2xl font-bold text-center text-[#76ABAE]"> 
            Tablas
        </h3>
        <div class="flex gap-8">
            <div class="overflow-y-scroll h-80 w-[220px] border-2 border-[#76ABAE]">
                <table id="tabla-vertices-1" class="text-[#EEEEEE] w-[200px]">
                    <thead class="w-full">
                        <tr class="w-full text-center">
                            <th class="w-1/2">X</th>
                            <th class="w-1/2">Y</th>
                        </tr>
                    </thead>
                    <tbody> 
                        <!-- Aquí se llenará la tabla con los datos -->
                    </tbody>
                </table>
            </div>
            <div class="overflow-y-scroll h-80 w-[220px] border-2 border-[#76ABAE]">
                <table id="tabla-vertices-2" class="text-[#EEEEEE] w-[200px]">
                    <thead class="w-full">
                        <tr class="w-full text-center">
                            <th class="w-1/2">X</th>
                            <th class="w-1/2">Y</th>
                        </tr>
                    </thead>
                    <tbody> 
                        <!-- Aquí se llenará la tabla con los datos -->
                    </tbody>
                </table>
            </div>
            <div class="overflow-y-scroll h-80 w-[220px] border-2 border-[#76ABAE]">
                <table id="tabla-vertices-3" class="text-[#EEEEEE] w-[200px]">
                    <thead class="w-full">
                        <tr class="w-full text-center">
                            <th class="w-1/2">X</th>
                            <th class="w-1/2">Y</th>
                        </tr>
                    </thead>
                    <tbody> 
                        <!-- Aquí se llenará la tabla con los datos -->
                    </tbody>
                </table>
            </div>
        </div>
    </dialog>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <!-- interaccion con dialog -->
    <script>
        // Obtener el botón y el diálogo por su ID
        var boton = document.getElementById("Mostrar");
        var dialogo = document.getElementById("dialog");

        // Cuando se hace clic en el botón, mostrar el diálogo
        boton.addEventListener("click", function() {
            dialogo.style.display = "block";
        });

        // Cuando se hace clic en el botón de cerrar, ocultar el diálogo
        document.getElementById("cerrarDialogo").addEventListener("click", function() {
            dialogo.style.display = "none";
        });
    </script>
    <!-- WebGL -->
    <script> 
        let x1, y1, x2, y2, x3, y3;
        let Chec_x1,Chec_y1;
        const lateral = [];
        let IsTarget = false;
        let isFirstRun = false;

        function updateX1() {
            // Obtener el valor del inputX1
            const inputX1 = document.getElementById('inputX1');
            // Asignar el valor del input a x1
            x1 = parseFloat(inputX1.value);
            Chec_x1 = x1;
        }
        function updateY1() {
            // Obtener el valor del inputX1
            const inputY1 = document.getElementById('inputY1');
            // Asignar el valor del input a x1
            y1 = parseFloat(inputY1.value);
            Chec_y1 = y1;
        }
        function updateX2() {
            // Obtener el valor del inputX1
            const inputX2 = document.getElementById('inputX2');
            // Asignar el valor del input a x1
            x2 = parseFloat(inputX2.value);
            // start();
        }
        function updateY2() {
            // Obtener el valor del inputX1
            const inputY2 = document.getElementById('inputY2');
            // Asignar el valor del input a x1
            y2 = parseFloat(inputY2.value);
            // start();
        }
        function updateX3() {
            // Obtener el valor del inputX1
            const inputX3 = document.getElementById('inputX3');
            // Asignar el valor del input a x1
            x3 = parseFloat(inputX3.value);
            // start();
        }
        function updateY3() {
            // Obtener el valor del inputX1
            const inputY3 = document.getElementById('inputY3');
            // Asignar el valor del input a x1
            y3 = parseFloat(inputY3.value);
            // start();
        }
        
        function Lineas(vertices,px_1,py_1,px_2,py_2,dis,tabla) {

            console.log(px_1,py_1);

            let Bool_x = false;
            let Bool_y = false;
            const VerTab = [];

            if(px_1 < px_2 ){
                Bool_x = true;
            }
            if(py_1 < py_2 ){
                Bool_y = true;
            } 

            let M = (py_2 - py_1)/(px_2 - px_1);
            let DX = (px_2 - px_1);
            let DY = (py_2 - py_1);

            DX = Math.abs(DX);
            DY = Math.abs(DY);

            let Pasos = DX > DY ? DX : DY; 
            let IN_X = DX / Pasos;
            let IN_Y = DY / Pasos;

            if (px_1 > px_2){
                IN_X = -IN_X;
            }
            if (py_1 > py_2){
                IN_Y = -IN_Y;
            }

            // Consola
            // console.log('x1 es el mayor? ', Bool_x, ', y1 es el mayor?',Bool_y);
            // console.log('DX : ',DX);
            // console.log('DY : ',DY);
            // console.log('pasos : ',Pasos);
            // console.log('IN_X : ',IN_X);
            // console.log('IN_Y : ',IN_Y);

            // Definir los vértices de la línea
            // vertices.push(px_1,py_1);
            // VerTab.push(px_1,py_1);

            if ((Bool_x == true)&&(Bool_y == true)){
                for (;(px_1 <= px_2) && (py_1 <= py_2);){
                    vertices.push(px_1,py_1);
                    VerTab.push(px_1,py_1);
                    if(IsTarget == true){
                        lateral.push(px_1,py_1);
                    }
                    px_1 += IN_X * dis;
                    py_1 += IN_Y * dis;
                    console.log(x1, y1);
                    if ((px_1 > 200) || (py_1 > 200)){
                        break;
                    }
                }
            } if ((Bool_x == false)&&(Bool_y == false)){
                for (;(px_1 >= px_2) && (py_1 >= py_2);){
                    vertices.push(px_1,py_1);
                    VerTab.push(px_1,py_1);
                    if(IsTarget == true){
                        lateral.push(px_1,py_1);
                    }
                    px_1 += IN_X * dis;
                    py_1 += IN_Y * dis;
                    console.log(px_1, py_1);
                    if ((px_1 > 200) || (py_1 > 200)){
                        break;
                    }
                }
            } if ((Bool_x == true)&&(Bool_y == false)){
                for (;(px_1 <= px_2) && (py_1 >= py_2);){
                    vertices.push(px_1,py_1);
                    VerTab.push(px_1,py_1);
                    if(IsTarget == true){
                        lateral.push(px_1,py_1);
                    }
                    px_1 += IN_X * dis;
                    py_1 += IN_Y * dis;
                    console.log(px_1, py_1);
                    if ((px_1 > 200) || (py_1 > 200)){
                        break;
                    }
                }
            } if ((Bool_x == false)&&(Bool_y == true)){
                for (;(px_1 >= px_2) && (py_1 <= py_2);){
                    vertices.push(px_1,py_1);
                    VerTab.push(px_1,py_1);
                    if(IsTarget == true){
                        lateral.push(px_1,py_1);
                    }
                    px_1 += IN_X * dis;
                    py_1 += IN_Y * dis;
                    console.log(px_1, py_1);
                    if ((px_1 > 200) || (py_1 > 200)){
                        break;
                    }
                }
            }
            vertices.push(px_2, py_2);
            VerTab.push(px_2,py_2);
            if(IsTarget == true){
                lateral.push(px_2,py_2);
            }
            
            if (VerTab.length > 4)
            {
                for (let i = 0; i < VerTab.length; i += 2) {
                    // Crear una nueva fila en la tabla
                    const fila = tabla.insertRow();

                    // Insertar la coordenada X en la primera celda de la fila
                    const celdaX = fila.insertCell(0);
                    celdaX.textContent = '' + VerTab[i];
                    // Crear una nueva fila para la coordenada Y
                    const celdaY = fila.insertCell(1);
                    celdaY.textContent = '' + VerTab[i + 1];
                }
            } 

            return vertices;
        }

        function LineaVariant(vertices,px_1,py_1,px_2,py_2,dis) { 
        let Bool_x = false;
        let Bool_y = false;

        if(px_1 < px_2 ){
            Bool_x = true;
        }
        if(py_1 < py_2 ){
            Bool_y = true;
        } 

        let M = (py_2 - py_1)/(px_2 - px_1);
        let DX = (px_2 - px_1);
        let DY = (py_2 - py_1);

        DX = Math.abs(DX);
        DY = Math.abs(DY);

        let Pasos = DX > DY ? DX : DY; 
        let IN_X = DX / Pasos;
        let IN_Y = DY / Pasos;

        if (px_1 > px_2){
            IN_X = -IN_X;
        }
        if (py_1 > py_2){
            IN_Y = -IN_Y;
        } 

        if ((Bool_x == true)&&(Bool_y == true)){
            for (;(px_1 <= px_2) && (py_1 <= py_2);){
                vertices.push(px_1,py_1);
                px_1 += IN_X * dis;
                py_1 += IN_Y * dis;
                console.log(x1, y1);
                if ((px_1 > 200) || (py_1 > 200)){
                    break;
                }
            }
        } if ((Bool_x == false)&&(Bool_y == false)){
            for (;(px_1 >= px_2) && (py_1 >= py_2);){
                vertices.push(px_1,py_1); 
                px_1 += IN_X * dis;
                py_1 += IN_Y * dis;
                console.log(px_1, py_1);
                if ((px_1 > 200) || (py_1 > 200)){
                    break;
                }
            }
        } if ((Bool_x == true)&&(Bool_y == false)){
            for (;(px_1 <= px_2) && (py_1 >= py_2);){
                vertices.push(px_1,py_1); 
                px_1 += IN_X * dis;
                py_1 += IN_Y * dis;
                console.log(px_1, py_1);
                if ((px_1 > 200) || (py_1 > 200)){
                    break;
                }
            }
        } if ((Bool_x == false)&&(Bool_y == true)){
            for (;(px_1 >= px_2) && (py_1 <= py_2);){
                vertices.push(px_1,py_1);
                px_1 += IN_X * dis;
                py_1 += IN_Y * dis;
                console.log(px_1, py_1);
                if ((px_1 > 200) || (py_1 > 200)){
                    break;
                }
            }
        }
        vertices.push(px_2, py_2);

        return vertices;
        }

        function limpiar(){
            const canvas = document.getElementById('webgl-canvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                console.error('Tu navegador no soporta WebGL');
                return;
            } 

            gl.clearColor(0.34, 0.40, 0.49, 1.0); // Color de fondo negro
            gl.clear(gl.COLOR_BUFFER_BIT);
        }

        function start() {
            const canvas = document.getElementById('webgl-canvas');
            const gl = canvas.getContext('webgl', {antialias:true} );
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            const aspectRat = canvasWidth / canvasHeight;
            gl.viewport(0, 0, canvasWidth, canvasHeight);

            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, -175, 175, -100, 100, -1, 1);

            const tabla1 = document.getElementById('tabla-vertices-1').getElementsByTagName('tbody')[0];
            const tabla2 = document.getElementById('tabla-vertices-2').getElementsByTagName('tbody')[0];
            const tabla3 = document.getElementById('tabla-vertices-3').getElementsByTagName('tbody')[0];

            // tabla1.innerHTML = '';
            // tabla2.innerHTML = '';
            // tabla3.innerHTML = '';

            // if (isFirstRun == true) { 
            //     tabla1.innerHTML = '';
            //     tabla2.innerHTML = '';
            //     tabla3.innerHTML = ''; 
            // }
            
            x1 = Chec_x1;
            y1 = Chec_y1;

            //  inicio 
            let dis = 0.1;
            const vertices = [];

            if (x1 != null){
                Lineas(vertices,x1,y1,x2,y2,dis,tabla1);
                IsTarget = true;
                Lineas(vertices,x2,y2,x3,y3,dis,tabla2);
                IsTarget = false;
                Lineas(vertices,x3,y3,x1,y1,dis,tabla3);

                // console.log(lateral.length,lateral);
                for(let i = 0; i <= lateral.length;) {
                    let x = lateral[i];
                    let y = lateral[i + 1];
                    LineaVariant(vertices,x1,y1,x,y,dis); 
                    i += 2;
                }
                isFirstRun = true;
            }

            if (!gl) {
                console.error('Tu navegador no soporta WebGL');
                return;
            } 

            // Crear un buffer para los vértices
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            // Crear el programa de shaders
            const vertexShaderSource = `
                attribute vec2 position;
                uniform mat4 u_projectionMatrix;
                void main() {
                    gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0);
                    gl_PointSize = 0.1; // Tamaño de los puntos
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                void main() {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                }
            `;

            // Crear los shaders
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);

            // Crear el programa
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

            // Pasar la matriz de proyección al shader
            const projectionMatrixLocation = gl.getUniformLocation(shaderProgram, 'u_projectionMatrix');
            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix
            // new Float32Array(shaderProgram)
            );

            // Vincular el buffer al atributo de posición del shader
            const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'position');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            // Limpiar el lienzo y dibujar la línea 
            gl.clearColor(0.34, 0.40, 0.49, 1.0); // Color de fondo negro
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, vertices.length / 2); // Dibujar puntos 
            gl.deleteBuffer(vertexBuffer); 
        } 
    </script>

</body>
</html>